import _ from 'lodash';

const storageData = JSON.parse(localStorage.getItem('feed'));

const initialState = storageData || {
  // TODO: 차후 테스트용 데이터 제거
  feed: {
    우아한형제들기술블로그: {
      description:
        '이 블로그는 배달의민족, 배민라이더스, 배민상회 등 Food Tech를 선도하는 우아한형제들 기술조직의 성장 일기를 다루는 블로그입니다.',
      feedUrl: 'http://woowabros.github.io/feed.xml',
      generator: 'Jekyll v3.8.5',
      items: [
        {
          categories: ['woowabros'],
          content:
            '<p>안녕하세요. 교육코스개발팀 이동규입니다.</p>↵↵<p>저희 팀은 5월 7일부터 <a',
          contentSnippet:
            '안녕하세요. 교육코스개발팀 이동규입니다.↵↵저희 팀은 5월 7일부터 우아한테크코스 교육을 진행하고 있습니다. 교육과 관련하여서는 이전의 포스팅에서 모집글과, 프리코스관련 글을 확인하실 수 있습니다.↵↵현재 우아한형제들은 다양한 DR (Developer Relations) 활동을 하고 있습니다. 우아한 테크 세미나는 우아한형제들의 DR 활동 중 하나로, 매달 다른 주제로 내외부 연사님들을 모셔 기술적 주제에 대해 살펴보는 시간으로 꾸며지며, 구성원들뿐만 아니라 같은 고민과 관심을 가진 외부 개발자분들도 초대하여 진행됩니다.↵↵이번 5월 테크 세미나엔 자바의 신, 자바 성능 튜닝 이야기 등의 저자이신 이상민 님께서 자바, 성능, 모니터링을 주제로 강의를 진행하셨습니다.↵↵↵↵#1 자바 성능 이야기↵↵성능의 개선 및 저하는 수익에 직접적인 영향을 줍니다. [관련 링크] 그래서 우리는 서비스가 얼마나 빠른지(Time), 일정 시간 동안 얼마나 많이 처리할 수 있는지(TPS), 그리고 얼마나 많은 사람들이 동시에 사용할 수 있는지(Users)에 대해 이야기합니다.↵↵하지만 성능 개선에는 한계가 생길 수밖에 없기에(암달의 법칙), 부하의 원인을 파악하여 이를 제거해야 합니다. 이때, 성능을 바라보는 관점은 각자 처한 상황에 따라 달라지게 됩니다.↵↵Users를 예로 들면, 시스템 관리자의 관점에서는 등록된 사용자와 등록되지 않은 사용자만이 존재하며, 서버의 관점에선 로그인한 사용자와 로그인하지 않은 사용자만이 존재합니다. 그리고 성능 테스터의 관점에선 사용자가 Concurrent User 인지 Active User 인지가 중요합니다. 여기서 Concurrent User란, 웹 페이지를 띄어놓은 사용자처럼, 언제든지 부하를 줄 수 있는 사용자를 의미합니다. 반면, Active User는 메뉴나 링크를 누르고 결과가 나오기를 기다리는 등 실제로 서버에 부하를 주고 있는 사용자를 의미합니다. Active User 와 Concurrent User 의 비율은 서비스의 성격에 따라 다르므로 이 점을 감안하고 성능테스트를 계획해야 합니다. (성능 테스트시에 VUser는 Active User와 유사합니다.) 가령 수강신청의 경우, 특정 시간대엔 그 비율이 90%에 육박할 수 있어, 전체 평균을 기준으로 테스트할 경우 잘못된 판단을 이끌어낼 수 있습니다.↵↵시간(Time) 역시 바라보는 관점에 따라 개념이 달라집니다. 사용자에게 있어서 Time은 응답시간만 존재합니다. 하지만 실제 시스템 입장에선, 사용자가 요청에 대해서 응답을 받은 후에 웹 페이지를 보는 등의 작업을 하는 시간(Think Time)이 존재합니다.↵↵↵↵성능 테스트 시엔 실제 지연시간이 발생하는 구간을 파악하여야 합니다. 가령 Server 구간에서 발생한 경우, DB와 애플리케이션 간 연결의 문제, 프로그램 로직 상의 문제 혹은 서버의 리소스 부족 등을 의심해 볼 수 있습니다. 또한 네트워크 이슈의 경우 테스트하는 환경에 따라 달라질 수도 있습니다. 지연 현상은 사용자의 이탈과 매우 밀접하기에 개선되어야 하지만, 단순히 서버를 늘린다고(Scale out) 해결되는 것은 아닙니다. 이에 출시 전에 테스트를 하여 최대 응답시간을 파악하고 있어야 하며, 상위 5%의 화면이 95% 사용자 요청을 받는다는 점을 감안하고 튜닝의 대상을 선정해가야 합니다.↵↵Time과 달리, TPS (Transaction Per Seconds)는 Scale out 혹은 Scale up을 통해 증가시킬 수 있습니다. 보통 테스트 시에 단순히 응답시간을 기준으로 종료시키진 않고, TPS나 DB Connection, CPU 등을 종합적으로 확인하고 중단시킵니다.↵↵↵↵User 증가 시 TPS는 어느 정도 증가하다가 더 이상 증가하지 않게 되며, Time은 일정하게 유지되다 점차적으로 증가합니다. 반면, 부하가 증가할 경우(TPS가 증가) 지연시간은 변곡점에 이르기도 하는데, 이 경우 시스템 리소스가 누수되고 있는 것은 아닌지 확인해봐야 합니다. 일반적으로 병목은 DB Connection, Web page 혹은 Network에서 발생하지만, 성능 튜닝의 목표 설정은 경험에 의존하기보단 데이터에 근거해 판단하여야 합니다. 추가적으로, 최적값을 설정하기 위해서는 해당 영역에 대한 깊이 있는 이해가 필요하며, 관련 전문가를 찾아가 문의하는 것도 좋습니다. (DBA와 친해지세요)↵↵↵↵성능을 테스트하기 위한 도구로는 HP의 상용 도구인 LoadRunner, JMeter, nGrinder, 그리고 Gatling 등이 있습니다. 이 중 Gatling의 경우 Jenkins Plugin이 제공되어 CI/CD pipeline에 쉽게 적용할 수 있는 점, Event와 Async IO 기반으로 JMeter, nGrinder 대비 성능상 이점이 있다는 점 [관련 링크] 등이 인상적이었습니다. [JIRA Performance Testing]↵↵#2 자바 이야기↵↵자바 라이선스에 대한 이야기로 2번째 세션이 시작되었습니다. Java 8은 공식 홈페이지에서 받아서 쓰면 문제가 없으며, Java 11부터는 회사에서 사용하게 될 경우 라이선스 문제가 복잡해질 여지가 있습니다. 맥북에서 개발용으로 사용하는 것은 괜찮지만, 배포본의 경우 회사 직원 수 혹은 서버별 과금이 발생할 수 있습니다. 따라서 openjdk를 사용하는 것도 검토해봐야 하며, 과금에 대한 자세한 부분은 공식 문서를 확인해보시길 바랍니다. 추가적으로, Java 버전에 대한 상세한 내용은 링크를 참조하시길 바랍니다.↵↵Java8이 등장하면서 Lambda, Stream, Optional, Default method, LocalDate / LocalTime 등이 추가되었습니다.↵↵  Lambda 표현식과 Stream 인터페이스의 경우 남용하면 오히려 가독성을 떨어트릴 수 있습니다.↵  for/foreach/stream 성능 비교에 대한 질문이 있었는데요, 현재 성능 차이는 거의 없다고 합니다.↵  ParallelStream은 CPU core 개수만큼 스레드를 사용하며 내부적으로 common fork join pool을 사용합니다. 이에 fork join pool을 사용하는 다른 thread에 영향을 줄 수도 받을 수도 있습니다. 따라서 운영환경에서는 주의해서 사용하여야 합니다.↵↵↵Java9의 주요 특징으로는 Compact Strings, G1 default GC가 있으며 그 외에도 Collections, JShell 등이 등장하였습니다.↵↵↵↵↵  웹 애플리케이션의 경우 String 클래스를 많이 사용하기 때문에, Java 버전을 올려주는 것만으로도 Compact Strings로 인한 성능 개선 효과를 얻을 수 있습니다. 기존에 String class는 char[]을 감싼 형태로 UTF-16기반의 2byte를 참조하였지만, Compact Strings는 byte[]을 채택함으로써 문자열에 따라 Latin-1(1byte) 혹은 UTF-16(2byte)로 인코딩된 문자를 저장하기에 메모리 공간 효율이 높아지고 GC 발생이 적어지는 효과가 있습니다.↵↵↵Java10에서는 var가 등장하였고, Java11부터는 Oracle JDK가 유료화되었으며 HTTP2, 웹소켓 등을 쉽게 사용할 수 있는 java.net.http.HttpClient가 제공됩니다. [관련 링크] ↵그리고 Java12의 특징으로는 Switch expressions, JMH 내장, Shenandoah gc가 있습니다.↵↵추가적으로, AdoptOpenJdk에 대해서 자세히 설명을 들을 수 있었습니다. AdoptOpenJdk는 Open source로, 600명 이상의 자원봉사자로 구성된 Commnunity가 주도하고 있으며, 별도의 제품이 아니라 IBM의 내부 자바 테스팅 인프라 등을 활용한 build farm에서 빌드를 해서 제공해줍니다. (CI/CD 지원을 의미)↵↵#3 자바 모니터링 이야기↵↵APM의 동작 방식을 이해하기 위해서는 BCI(Byte Code Instrumentation)에 대해 이야기해야 합니다. BCI란 런타임이나 로드 시에 클래스의 바이트 코드에 변경을 가하는 기법으로, 소스파일의 수정 없이 원하는 기능을 부여할 수 있고 필요한 정보를 추적할 수 있습니다. Spring AOP 역시 BCI를 사용하고 있습니다. 관련하여 java.lang.instrument pacakge와 ClassFileTransformer interface 문서를 확인해보시길 권장합니다. [관련 링크] BCI 도구로는 대표적으로 ASM, BCEL, Javassist가 있으며 제니퍼의 경우 BCEL을, 핀포인트의 경우 Javassist를 사용한다고 합니다.↵↵추가적으로, APM에서 서버 간 호출 관계를 어떻게 추적하는지에 대한 이야기가 이어졌습니다. 핀포인트의 경우, 서버로부터 요청이 오면 Http header에서 caller를 확인하고 caller가 없으면 자신을 caller로 등록합니다. 그리고 다른 서버에 요청할 때 자신이 생성한 id를 Http header에 넘겨주는데, 이런 연결들이 이루어져 관계가 구성되고 분산 추적이 가능해집니다. [관련 링크] 따라서 소켓 통신의 경우 패킷을 나누기 때문에 헤더를 추적하는 방식으로는 분석이 불가능합니다.↵↵↵↵상용 APM은 대표적으로, Dynatrace, New relic, AppDynamics, WhaTap 등이 있으며, 오픈소스로는 Scouter, Pinpoint 등이 있습니다. 이 중 Scouter와 Pinpoint를 비교해보면, Scouter는 실시간 모니터링, 트러블슈팅을 위한 지표가 많고 Pinpoint의 경우 전체 뷰 등 서버 간 관계를 지켜볼 수 있고 분산 저장이 가능하다는 이점이 있습니다. Scouter로 모니터링할 경우에는 CPU, TPS, Active Service EQ, GC time, GC count, Xlog 등의 지표를 구성할 수 있습니다. 이 중 CPU와 TPS는 기간별 trends를 확인할 수 있으며, Active Service EQ는 시각적으로 서비스의 상태를 확인하고 Thread 목록과 StackTrace 목록을 찾아가기 쉽게 구성되어 있어, 문제가 되는 서버를 추적하기가 용이합니다. Scouter에는 이 외에도 알람, 성능 카운터, Summary, Xlog data 전처리, Xlog 상세 profile 정보 전처리 등을 위한 Server 측의 플러그인을 제공하며 Agent 측에서는 httpservice, httpcall, capture, jdbcpull 등의 플러그인을 제공하고 있습니다. 이 중 capture.plug의 경우 특정 메서드를 지정하면 해당 메서드가 호출되었을 때 리턴 값을 확인할 수 있다고 합니다.↵추가적으로 Scouter 설정값과 관련하여서는 Server와 Agent 모두 Configure Class에서 확인이 가능합니다. [관련 링크]↵↵그리고 Scouter가 현재 커미터를 모집 중이니 많은 참여 바랍니다.↵↵↵ ↵ ↵↵# QnA↵↵↵  ↵    java null에 대한 질문: 관련자료 [관련 링크]↵  ↵  ↵    GC 튜닝에 대한 질문↵↵    GC 튜닝은 가장 마지막에 하는 것이라고 합니다. 왜 애플리케이션이 메모리를 많이 사용하는지, 왜 임시 객체를 많이 사용하는지를 먼저 확인하여야 하며, Thread와 DB connection pool을 최적화하는 것도 중요합니다. DB Connection Pool의 경우 기본이 10개라, 그 이상 들어오면 대기큐에 들어가고, 이에 Connection Time이 길어질 수도 있다고 합니다. 또한 서비스 규모에 따라 로그가 시스템에 큰 영향을 미칠 수도 있습니다. 최근의 stack trace를 보면 여러 줄이 뒤죽박죽 섞여있지 않은 것을 확인할 수 있는데요. 로그를 작성하기 위해 락을 걸어 성능에 영향을 줄 수 있습니다. 따라서 로그는 꼭 필요한 것만 작성하도록 하여야 합니다.↵GC 옵션을 결정하는 것과 관련해서는 직접 화이트보드에 쓰시면서 설명해주셨는데요. 절대적인 GC 옵션을 지정하는 것은 어렵고 메모리를 늘려가며 Full GC time을 측정한 후 서비스 특성을 고려하여 결정해야 한다고 하셨습니다.↵  ↵  ↵    JVM이 비정상적으로 죽은 경우에 대한 질문↵↵    JVM이 비정상적으로 죽으면 hs_err로 시작하는 파일이 java project를 실행하는 폴더 안에 생기므로 이를 분석해야 한다고 합니다.↵  ↵  ↵    APM으로 인한 성능 저하에 대한 질문↵↵    Dynatrace는 성능 저하가 5%나면 Collector가 분석하는 데이터량을 줄인다고 합니다. 하지만 오픈소스를 사용하게 될 경우, 성능 저하가 얼마나 나는지는 직접 비교해봐야 합니다. 모니터링하는 서버와 하지 않는 서버의 CPU를 비교하고, 많이 차이 날 경우엔 샘플링하는 것을 고려해야 합니다.↵  ↵↵↵마지막으로, 절대 단정 짓지 말고 직접 확인하여 데이터로 이야기해야 한다는 점을 거듭 강조하셨습니다.↵↵# 개인적인 소감↵↵‘자바의 신’을 기본서로 시작하여, ‘자바 성능 튜닝 이야기’로 면접을 준비하였고, 지금은 ‘자바 개발자와 시스템 운영자를 위한 트러블 슈팅 이야기’를 읽고 있습니다. 이 세미나를 통해 성능에 대한 깊이 있는 이해를 얻겠다는 생각보단, 팬심으로 지원했던 것 같습니다. 하지만 기대했던 것보다 많은 영감을 받을 수 있었고, 흥미가 가는 키워드도 많이 얻어 갈 수 있었습니다. 특히 (여기엔 다룰 수 없었지만) 여러 가지 사례들을 통해 지표를 바라보는 관점들을 엿볼 수 있어서 너무 좋았습니다.↵↵우아한 테크세미나는 매월 진행되고 있습니다. 다음 세미나 역시 매우 매력적인 연사님께서 준비하고 계시다고 하니, 이번에 못 오신 분들은 다음 세미나를 노려보시는 것도 좋을 거 같습니다.',
          guid:
            'http://woowabros.github.io/woowabros/2019/05/09/techseminar-java-performance.html',
          isoDate: '2019-05-09T00:00:00.000Z',
          link:
            'http://woowabros.github.io/woowabros/2019/05/09/techseminar-java-performance.html',
          pubDate: 'Thu, 09 May 2019 09:00:00 +0900',
          title: '5월 우아한 Tech 세미나 후기',
        },
        {
          categories: ['woowabros'],
          content:
            '<p>나는 우아한형제들에서 <a href="https://woowacourse.github.io/">우아한테크코스</a>(이하 우테코) 교육 과정을 진행하고 있다. 우테코를 설계하면서 고민스러웠던 부분 중의 하나는 ‘선발 과정을 어떻게 하면 의미 있는 시간으로 만들 것인가?’였다. 보통의 선발 과정은 경쟁을 통해 누군가를 선발해야 하는 것이 가장 큰 목적이다. 선발도 중요하지만 선발 과정에서 배움을 만들고 성장할 수 있는 시간으로 만들어 보고 싶었다. 이 목표를 달성하기 위해 선발 과정에 프리코스라는 3주간의 과정을 추가했다.</p>↵↵<p>우테코는 지식 중심의 교육 과정이 아니다. 경험 중심의 교육 과정으로 매주마다 미션을 부여하고, 이에 대한 피드백을 받는 방식으로 진행한다. 약간은 생소한 교육 과정이기 때문에 본 과정을 미리 경험해 보는 단계로 프리코스를 추가한 이유도 있다. 이 과정을 통해 지원자는 본 과정을 미리 경험해 보면서 교육의 참여 여부를 결정할 수 있고, 우테코는 본 과정을 소화하는데 어려움이 없는지 판단하는 시간으로 설계했다.</p>↵↵<p>지난주에 모든 선발 과정이 끝났다. ‘선발도 진행하면서 그 과정에서 배움과 성장을 만들어 보겠다.’는 처음의 목표를 일정 부분 성공한 측면이 있어 공유하려고 이 글을 시작한다.</p>↵↵<h2 id="목적의식-있는-연습이란">목적의식 있는 연습이란?</h2>↵<p>이를 평생 닦는다고 이를 닦는 기술이 좋아지는가? 20대 이후부터 운전을 한다고 운전 기술이 나아지는가? 나는 평생 동안 같은 방법으로 이를 닦는다. 20년 이상 운전을 했지만 아직도 주차할 때 전진과 후진을 반복하는 경우가 다반사이다. 몸치인 아내가 에어로빅을 시작한 지 10년이 되었지만, 웨이브는 뻣뻣하고 다이어트도 성공하지 못했다. 체중이 늘지 않으면 다행이다.</p>↵↵<p>우리는 최초 무엇인가를 배울 때 책, 인터넷, 교육 기관을 통해 전반적인 개념, 기술을 익히고 배운다. 일정 수준에 도달할 때까지 반복 연습을 한다. 연습을 반복하다 보면 의식하지 않아도 기계적으로 할 수 있는 수준에 도달한다. 만족해하며 자신이 연습한 일을 즐기며 기계적으로 반복한다. 이렇게 5년, 10년을 반복해 경험을 쌓으면 자연스럽게 역량이 향상되리라 믿는다. 우리가 학습과 관련해 흔히 잘못 알고 있는 오해이다. 운전을 하고, 피아노를 연주하고, 테니스를 치는 것이 연습이라 생각하고 반복한다. 하지만 기계적으로 같은 연습을 반복한다고 해서 역량이 좋아지지 않는다.</p>↵↵<p>자신이 새로운 무엇인가를 배울 때를 떠올려 보자. 시작하는 단계는 익숙하지 않기 때문에 상당히 의식적으로 노력해야 한다. 긴장감 때문에 몸이 굳어지거나 부자연스러운 경험을 한다. 하지만 반복 연습을 하다 보면 의식하지 않아도 기계적으로 할 수 있는 단계가 된다. 이와 같이 몸이 굳어지고, 부자연스러운 상태를 벗어나기 위해 의식적으로 노력하는 순간이 진정한 배움과 학습이 일어나는 순간이다. 내가 현재 수준에 만족하고 더 이상의 의식적인 노력을 하지 않는다면 그 순간 성장이 멈추는 단계이다. 무작정 반복하고 경력을 쌓는다고 해서 성장하지 않는다. 20년 경력의 의사가 5년 경력의 의사보다 환자의 병을 잘 진단한다고 볼 수 없다. 경력을 쌓는 과정에서 의식적인 노력을 통해 다음 단계로 성장하기 위해 노력했느냐에 따라 달라지는 것이다.</p>↵↵<p>3주라는 짧은 기간에 효과적으로 연습하도록 하기 위해 의식적인 연습을 기반으로 미션을 진행하도록 설계했다. 교육자로 살다 보니 효과적인 학습 방법에 대한 관심이 높아졌다. 효과적인 학습 방법을 찾던 중 “1만 시간의 재발견”이라는 책을 통해 의식적인 연습의 중요성을 느낄 수 있는 계기가 되었다.</p>↵↵<p><img src="/img/2019-05-02/self-conscious.jpeg" alt="" /></p>↵↵<p>이 책은 의식적인 연습과 목적의식 있는 연습을 구분해 설명하고 있다. 이 글에서 둘의 차이점을 설명하기 어려운 점이 있기 때문에 둘을 같다고 가정하고 글을 진행한다. 의식적인 연습과 목적의식 있는 연습의 차이점에 대해 알고 싶다면 이 책을 읽어볼 것을 추천한다. 이 책에서는 ‘목적의식 있는 연습’의 특징을 다음과 같이 제시하고 있다.</p>↵↵<ul>↵  <li>‘목적의식 있는 연습’은 <strong>명확하고 구체적인 목표</strong>를 가지고 있다.</li>↵  <li>‘목적의식 있는 연습’에는 <strong>집중</strong>이 필요하다.</li>↵  <li>‘목적의식 있는 연습’에는 <strong>피드백</strong>이 필요하다.</li>↵  <li>‘목적의식 있는 연습’은 자신의 <strong>컴포트 존에서 벗어날 것</strong>을 요구한다.</li>↵</ul>↵↵<p>컴포트 존은 자신이 편안함을 느끼는 상태를 의미한다. 즉, 일정 수준의 연습을 통해 의식하지 않아도 기계적으로 할 수 있는 상태가 컴포트 존이라 할 수 있다. 우리가 헬스클럽에서 벤치 프레스를 할 때 이전에 했던 횟수보다 한 개를 더 하는 시점에 진정한 운동 효과가 있다는 이야기가 있다. 이와 비슷한 맥락으로 자신의 익숙한 환경을 깨고 벗어나려는 노력 속에서 진정한 성장을 맛볼 수 있는 것이다.</p>↵↵<h2 id="목적의식-있는-연습으로-프리코스-설계">목적의식 있는 연습으로 프리코스 설계</h2>↵<p>3주라는 짧은 기간이다. 하지만 우테코에 합격하고 싶은 동기부여는 높다. 따라서 ‘목적의식 있는 연습’의 특징 중 ‘집중이 필요하다’, ‘자신의 컴포트 존에서 벗어날 것을 요구한다.’ 두 가지는 자연스럽게 달성할 수 있으리라 기대했다. 나머지 ‘명확하고 구체적인 목표’를 가지고 연습하도록 과정을 설계하고, 피드백을 준다면 ‘목적의식 있는 연습’의 특징을 달성할 수 있겠다.</p>↵↵<p>매주 미션은 구현한 프로그램에 대한 기능 요구사항, 프로그래밍 요구사항, 미션 진행 요구사항 3가지로 나뉘었다. 매주 구현할 기능에 대한 요구사항의 난이도를 조금씩 높여 나갔지만 그리 어려운 문제는 아니었다. 미션 진행을 위한 요구사항은 3주 동안 다음과 같았다.</p>↵↵<ul>↵  <li>기능을 구현하기 전에 README.md 파일에 구현할 기능 목록을 정리해 추가한다.</li>↵  <li>git의 commit 단위는 앞 단계에서 README.md 파일에 정리한 기능 목록 단위로 추가한다.</li>↵</ul>↵↵<p>‘목적의식 있는 연습’에 집중한 부분은 프로그래밍 요구사항이었다. 지금까지 프로그래밍을 연습하면서 의식적으로 신경 쓰지 않았던 부분에 대한 제약사항을 제시했다. 제약사항은 ‘명확하고 구체적인 목표’가 되도록 하기 위해 정성적으로 제시하지 않고 정량적으로 제시했다. 매주 제약사항의 난이도를 단계적으로 높이도록 설계했다. 3주간의 과정을 다음과 같이 진행했다.↵<br />↵<br />↵<img src="/img/2019-05-02/programming_1st.png" alt="" width="70%" height="70%" /></p>↵↵<p>1주일 후에 과제를 제출하면 평가를 진행한다. 평가를 진행하면서 공통적으로 실수하는 부분을 2주 차 요구사항을 부여하면서 피드백으로 같이 제공했다.</p>↵↵<p><a href="/files/2019-05-02/precourse_1st_feedback.pdf">프리코스_1주차_피드백.pdf</a>↵<br />↵<br />↵<img src="/img/2019-05-02/programming_2nd_1.png" alt="" width="70%" height="70%" />↵<br />↵<img src="/img/2019-05-02/programming_2nd_2.png" alt="" width="70%" height="70%" /></p>↵↵<p>1주일 후에 과제를 제출하면 평가를 진행한다. 평가를 진행하면서 공통적으로 실수하는 부분을 3주 차 요구사항을 부여하면서 피드백으로 같이 제공했다.</p>↵↵<p><a href="/files/2019-05-02/precourse_2nd_feedback.pdf">프리코스_2주차_피드백.pdf</a>↵<br />↵<br />↵<img src="/img/2019-05-02/programming_3rd_1.png" alt="" width="70%" height="70%" />↵<br />↵<img src="/img/2019-05-02/programming_3rd_2.png" alt="" width="70%" height="70%" /></p>↵↵<p>3주 과정이 끝난 후 마지막 미션에 대한 피드백을 제공했다.</p>↵↵<p><a href="/files/2019-05-02/precourse_3rd_feedback.pdf">프리코스_3주차_피드백.pdf</a></p>↵↵<h2 id="프리코스-진행-결과">프리코스 진행 결과</h2>↵<p>3주 동안 프리코스를 진행하면서도 참여자들의 실력이 많이 향상되고 있음을 느꼈다. 3주 동안 프리코스를 진행하고 오프라인 최종 테스트를 진행했다. 오프라인 최종 테스트가 4시간이라는 짧은 시간 동안 진행하기 때문에 큰 기대를 하지 않았다. 그런데 테스트 결과는 기대 이상이었다. 3주 동안 요구한 부분을 충실하게 지키면서 최종 테스트를 진행했다. 그중 2개의 테스트 결과물을 공유해 본다.</p>↵↵<p>응시자 1</p>↵<ul>↵  <li><a href="https://github.com/yuyu154/java-movie/blob/c8e2572b61ee76d9d329721add619e1654dc7cb9/README.md">README.md 파일에 작성한 기능 구현 목록</a></li>↵  <li><a href="https://github.com/woowacourse/java-movie-2019/pull/91/commits">커밋 로그</a></li>↵  <li><a href="https://github.com/woowacourse/java-movie-2019/pull/91/files">구현 코드</a></li>↵</ul>↵↵<p>응시자 2</p>↵<ul>↵  <li><a href="https://github.com/vsh123/java-movie/blob/d1ab6439a529fd957ec7b06085f0cfdeed9187cf/README.md">README.md 파일에 작성한 기능 구현 목록</a></li>↵  <li><a href="https://github.com/woowacourse/java-movie-2019/pull/33/commits">커밋 로그</a></li>↵  <li><a href="https://github.com/woowacourse/java-movie-2019/pull/33/files">구현 코드</a></li>↵</ul>↵↵<p>테스트 시간이 4시간밖에 되지 않았는데 README.md 파일에 구현할 기능 목록을 정리하고, 기능 단위에 따라 커밋 로그를 작성한 점이 인상적이었다. 구현한 코드 또한 프로그래밍 요구사항을 충실히 지키면서 구현하려고 노력한 모습을 보면서 3주 동안 정말 열심히 연습했다는 인상을 받을 수 있었다.</p>↵↵<h2 id="프리코스-참여-후기">프리코스 참여 후기</h2>↵<p>선발 과정에서도 배움과 성장을 만들어보려고 최초 목표를 달성했는지의 여부는 오프라인 최종 테스트 결과물을 통해 느낄 수 있었다. 또한 3주 차 프리코스를 끝낸 후, 최종 발표 이후 참여한 친구들의 참여 후기를 통해서도 느낄 수 있었다. 참여 후기 중 일부를 공유함으로써 프리코스 과정에 참여하는 동안 이 친구들이 느꼈던 감정을 전해 본다.</p>↵↵<blockquote>↵  <ol>↵    <li>프리코스는 project driven, 자기 주도적인 학습 방식으로 진행됩니다.</li>↵    <li>좋은 코드를 짜는 것, 너무나 중요합니다.</li>↵    <li>코스 정말 재미있고 배울 것들 너무 많습니다. 그리고 어디 가서 이렇게 코드리뷰 받아볼 수 있는 기회 별로 없습니다.</li>↵  </ol>↵↵  <p><a href="https://deockstory.tistory.com/2">[우아한 테크코스] 프리코스 후기</a> 글 중에서</p>↵</blockquote>↵↵<p><br /></p>↵↵<blockquote>↵  <p>누가 앞에서 공자왈 맹자왈 하지 않았는데도 스스로 느끼고 알아낸 점도 정말 정말 뿌듯한 일이다. 주도적으로 문제를 해결하려 하면, 알아야 하는 지식들이 어렵지 않고 오히려 재밌어지는 것을 다시 한번 확인했다.</p>↵↵  <p>그리고 무엇보다, 같은 코스를 진행하는 그 분과의 대화. 가장 즐거운 경험이었다. 내가 생각한 방법, 그가 생각한 방법, 그분이 나에게 해준 좋은 말… 지극히 즐겁고 감사한 일이다. 내가 세계 속에 있음을 느끼게 했다.</p>↵↵  <p><a href="https://andole87.github.io/idea/woowahan-course/#">우아한테크코스 - 프리코스까지</a> 글 중에서</p>↵</blockquote>↵↵<p><br /></p>↵↵<blockquote>↵  <p>여담인데, 실제로 최근의 저의 상태를 지켜보던 여자 친구가 했던 말입니다.</p>↵↵  <p>세상에 취업 준비를 이렇게 즐거워하면서 하는 사람이 어디 있어!</p>↵↵  <p><a href="https://wbluke.com/blog/2019/04/11/%EB%B8%94%EB%A1%9C%EA%B7%B8_%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC%EC%BD%94%EC%8A%A4_%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4_%ED%9B%84%EA%B8%B0/">우아한 테크코스 - 프리코스 후기</a> 글 중에서</p>↵</blockquote>↵↵<p><br /></p>↵↵<blockquote>↵  <p>가장 좋았던 점은 매주 과제에 대한 피드백이 이루어졌다는 것이다. 물론 많은 인원이 진행되는 과정이었기 때문에 개인별 피드백은 아니었지만, 참가자들의 과제를 리뷰하시면서 많은 사람들이 어려워하거나 알았으면 하는 점을 모아 전달해주는 점이 무엇보다 좋았다. 피드백을 통해 느끼는 점이 정말 많았으며 이로 인해 정말 많은 도움이 됐다.</p>↵↵  <p><a href="https://mrvan.tistory.com/23">2019년 우아한테크코스 프리코스까지의 후기</a> 글 중에서</p>↵</blockquote>↵↵<p><br /></p>↵↵<p>최종 탈락 메일을 받은 후 다음과 같은 메일을 보내온 친구도 있다.</p>↵↵<blockquote>↵  <p>우아한 테크코스는 우물 안의 개구리였던 저에게 신세계의 존재를 가르쳐준 고마운 경험입니다. 그 자체로도 저는 이미 얻은 것이 많아서 행복합니다.</p>↵↵  <p>뭘 어떻게 공부해야 될지 추상적이었던 저에게 아직도 성장할 수 있는 부분이 많음을 깨우쳐주셔서 감사합니다.</p>↵</blockquote>↵↵<p>이 같은 참여후기와 메일을 받고 보니 과정을 설계하고, 평가하고, 피드백을 준 모든 과정이 보람으로 다가왔다. 프리코스에 적극적으로 참여한 모든 친구들에게 감사의 말을 전하고 싶다.</p>↵↵<h2 id="프리코스-진행을-통해-느낀-점">프리코스 진행을 통해 느낀 점</h2>↵<p>3주라는 짧은 기간 동안 프리코스를 진행하며 느낀 점을 정리하면서 글을 마친다.</p>↵↵<p>첫째, 지금까지 프로그래밍 연습을 하면서 코드 컨벤션을 지키라는 피드백을 받아본 경험이 있는 친구가 거의 없었다. 소프트웨어 교육을 진행할 때 최소한의 코드 품질 관련 교육이 진행되면 좋겠다.</p>↵↵<p>둘째, 동기부여가 높은 상태에서 ‘명확하고 구체적인 목표’를 달성하도록 과제를 제시한다면 과제를 진행하는 것이 고통이 아니라 즐거움이 될 수 있다. 과정을 잘 설계하면 학습이 재미있다는 경험을 전달할 수도 있겠다.</p>↵↵<p>셋째, 오프라인 과정을 최소화하고 온라인 과정을 통해서도 충분히 의미 있는 성장을 만들어 낼 수 있겠다. 지금까지 온라인과 오프라인을 병행해야만 의미 있는 과정을 만들 수 있겠다는 생각을 했는데 온라인 만으로도 충분히 의미 있는 결과를 만들 수 있는 과정을 설계할 수 있겠다.</p>↵↵<p>선발 과정을 통해 참 많은 것을 보고 배웠다. 하지만 본격적인 교육은 이제 시작이다. 본 교육 과정을 통해 또 다른 즐거움을 경험할 수 있기를 기대해 본다. 본 교육이 시작되는 5월 7일이 기대된다.</p>↵',
          contentSnippet:
            '나는 우아한형제들에서 우아한테크코스(이하 우테코) 교육 과정을 진행하고 있다. 우테코를 설계하면서 고민스러웠던 부분 중의 하나는 ‘선발 과정을 어떻게 하면 의미 있는 시간으로 만들 것인가?’였다. 보통의 선발 과정은 경쟁을 통해 누군가를 선발해야 하는 것이 가장 큰 목적이다. 선발도 중요하지만 선발 과정에서 배움을 만들고 성장할 수 있는 시간으로 만들어 보고 싶었다. 이 목표를 달성하기 위해 선발 과정에 프리코스라는 3주간의 과정을 추가했다.↵↵우테코는 지식 중심의 교육 과정이 아니다. 경험 중심의 교육 과정으로 매주마다 미션을 부여하고, 이에 대한 피드백을 받는 방식으로 진행한다. 약간은 생소한 교육 과정이기 때문에 본 과정을 미리 경험해 보는 단계로 프리코스를 추가한 이유도 있다. 이 과정을 통해 지원자는 본 과정을 미리 경험해 보면서 교육의 참여 여부를 결정할 수 있고, 우테코는 본 과정을 소화하는데 어려움이 없는지 판단하는 시간으로 설계했다.↵↵지난주에 모든 선발 과정이 끝났다. ‘선발도 진행하면서 그 과정에서 배움과 성장을 만들어 보겠다.’는 처음의 목표를 일정 부분 성공한 측면이 있어 공유하려고 이 글을 시작한다.↵↵목적의식 있는 연습이란?↵이를 평생 닦는다고 이를 닦는 기술이 좋아지는가? 20대 이후부터 운전을 한다고 운전 기술이 나아지는가? 나는 평생 동안 같은 방법으로 이를 닦는다. 20년 이상 운전을 했지만 아직도 주차할 때 전진과 후진을 반복하는 경우가 다반사이다. 몸치인 아내가 에어로빅을 시작한 지 10년이 되었지만, 웨이브는 뻣뻣하고 다이어트도 성공하지 못했다. 체중이 늘지 않으면 다행이다.↵↵우리는 최초 무엇인가를 배울 때 책, 인터넷, 교육 기관을 통해 전반적인 개념, 기술을 익히고 배운다. 일정 수준에 도달할 때까지 반복 연습을 한다. 연습을 반복하다 보면 의식하지 않아도 기계적으로 할 수 있는 수준에 도달한다. 만족해하며 자신이 연습한 일을 즐기며 기계적으로 반복한다. 이렇게 5년, 10년을 반복해 경험을 쌓으면 자연스럽게 역량이 향상되리라 믿는다. 우리가 학습과 관련해 흔히 잘못 알고 있는 오해이다. 운전을 하고, 피아노를 연주하고, 테니스를 치는 것이 연습이라 생각하고 반복한다. 하지만 기계적으로 같은 연습을 반복한다고 해서 역량이 좋아지지 않는다.↵↵자신이 새로운 무엇인가를 배울 때를 떠올려 보자. 시작하는 단계는 익숙하지 않기 때문에 상당히 의식적으로 노력해야 한다. 긴장감 때문에 몸이 굳어지거나 부자연스러운 경험을 한다. 하지만 반복 연습을 하다 보면 의식하지 않아도 기계적으로 할 수 있는 단계가 된다. 이와 같이 몸이 굳어지고, 부자연스러운 상태를 벗어나기 위해 의식적으로 노력하는 순간이 진정한 배움과 학습이 일어나는 순간이다. 내가 현재 수준에 만족하고 더 이상의 의식적인 노력을 하지 않는다면 그 순간 성장이 멈추는 단계이다. 무작정 반복하고 경력을 쌓는다고 해서 성장하지 않는다. 20년 경력의 의사가 5년 경력의 의사보다 환자의 병을 잘 진단한다고 볼 수 없다. 경력을 쌓는 과정에서 의식적인 노력을 통해 다음 단계로 성장하기 위해 노력했느냐에 따라 달라지는 것이다.↵↵3주라는 짧은 기간에 효과적으로 연습하도록 하기 위해 의식적인 연습을 기반으로 미션을 진행하도록 설계했다. 교육자로 살다 보니 효과적인 학습 방법에 대한 관심이 높아졌다. 효과적인 학습 방법을 찾던 중 “1만 시간의 재발견”이라는 책을 통해 의식적인 연습의 중요성을 느낄 수 있는 계기가 되었다.↵↵↵↵이 책은 의식적인 연습과 목적의식 있는 연습을 구분해 설명하고 있다. 이 글에서 둘의 차이점을 설명하기 어려운 점이 있기 때문에 둘을 같다고 가정하고 글을 진행한다. 의식적인 연습과 목적의식 있는 연습의 차이점에 대해 알고 싶다면 이 책을 읽어볼 것을 추천한다. 이 책에서는 ‘목적의식 있는 연습’의 특징을 다음과 같이 제시하고 있다.↵↵↵  ‘목적의식 있는 연습’은 명확하고 구체적인 목표를 가지고 있다.↵  ‘목적의식 있는 연습’에는 집중이 필요하다.↵  ‘목적의식 있는 연습’에는 피드백이 필요하다.↵  ‘목적의식 있는 연습’은 자신의 컴포트 존에서 벗어날 것을 요구한다.↵↵↵컴포트 존은 자신이 편안함을 느끼는 상태를 의미한다. 즉, 일정 수준의 연습을 통해 의식하지 않아도 기계적으로 할 수 있는 상태가 컴포트 존이라 할 수 있다. 우리가 헬스클럽에서 벤치 프레스를 할 때 이전에 했던 횟수보다 한 개를 더 하는 시점에 진정한 운동 효과가 있다는 이야기가 있다. 이와 비슷한 맥락으로 자신의 익숙한 환경을 깨고 벗어나려는 노력 속에서 진정한 성장을 맛볼 수 있는 것이다.↵↵목적의식 있는 연습으로 프리코스 설계↵3주라는 짧은 기간이다. 하지만 우테코에 합격하고 싶은 동기부여는 높다. 따라서 ‘목적의식 있는 연습’의 특징 중 ‘집중이 필요하다’, ‘자신의 컴포트 존에서 벗어날 것을 요구한다.’ 두 가지는 자연스럽게 달성할 수 있으리라 기대했다. 나머지 ‘명확하고 구체적인 목표’를 가지고 연습하도록 과정을 설계하고, 피드백을 준다면 ‘목적의식 있는 연습’의 특징을 달성할 수 있겠다.↵↵매주 미션은 구현한 프로그램에 대한 기능 요구사항, 프로그래밍 요구사항, 미션 진행 요구사항 3가지로 나뉘었다. 매주 구현할 기능에 대한 요구사항의 난이도를 조금씩 높여 나갔지만 그리 어려운 문제는 아니었다. 미션 진행을 위한 요구사항은 3주 동안 다음과 같았다.↵↵↵  기능을 구현하기 전에 README.md 파일에 구현할 기능 목록을 정리해 추가한다.↵  git의 commit 단위는 앞 단계에서 README.md 파일에 정리한 기능 목록 단위로 추가한다.↵↵↵‘목적의식 있는 연습’에 집중한 부분은 프로그래밍 요구사항이었다. 지금까지 프로그래밍을 연습하면서 의식적으로 신경 쓰지 않았던 부분에 대한 제약사항을 제시했다. 제약사항은 ‘명확하고 구체적인 목표’가 되도록 하기 위해 정성적으로 제시하지 않고 정량적으로 제시했다. 매주 제약사항의 난이도를 단계적으로 높이도록 설계했다. 3주간의 과정을 다음과 같이 진행했다.↵↵↵↵↵1주일 후에 과제를 제출하면 평가를 진행한다. 평가를 진행하면서 공통적으로 실수하는 부분을 2주 차 요구사항을 부여하면서 피드백으로 같이 제공했다.↵↵프리코스_1주차_피드백.pdf↵↵↵↵↵↵↵1주일 후에 과제를 제출하면 평가를 진행한다. 평가를 진행하면서 공통적으로 실수하는 부분을 3주 차 요구사항을 부여하면서 피드백으로 같이 제공했다.↵↵프리코스_2주차_피드백.pdf↵↵↵↵↵↵↵3주 과정이 끝난 후 마지막 미션에 대한 피드백을 제공했다.↵↵프리코스_3주차_피드백.pdf↵↵프리코스 진행 결과↵3주 동안 프리코스를 진행하면서도 참여자들의 실력이 많이 향상되고 있음을 느꼈다. 3주 동안 프리코스를 진행하고 오프라인 최종 테스트를 진행했다. 오프라인 최종 테스트가 4시간이라는 짧은 시간 동안 진행하기 때문에 큰 기대를 하지 않았다. 그런데 테스트 결과는 기대 이상이었다. 3주 동안 요구한 부분을 충실하게 지키면서 최종 테스트를 진행했다. 그중 2개의 테스트 결과물을 공유해 본다.↵↵응시자 1↵↵  README.md 파일에 작성한 기능 구현 목록↵  커밋 로그↵  구현 코드↵↵↵응시자 2↵↵  README.md 파일에 작성한 기능 구현 목록↵  커밋 로그↵  구현 코드↵↵↵테스트 시간이 4시간밖에 되지 않았는데 README.md 파일에 구현할 기능 목록을 정리하고, 기능 단위에 따라 커밋 로그를 작성한 점이 인상적이었다. 구현한 코드 또한 프로그래밍 요구사항을 충실히 지키면서 구현하려고 노력한 모습을 보면서 3주 동안 정말 열심히 연습했다는 인상을 받을 수 있었다.↵↵프리코스 참여 후기↵선발 과정에서도 배움과 성장을 만들어보려고 최초 목표를 달성했는지의 여부는 오프라인 최종 테스트 결과물을 통해 느낄 수 있었다. 또한 3주 차 프리코스를 끝낸 후, 최종 발표 이후 참여한 친구들의 참여 후기를 통해서도 느낄 수 있었다. 참여 후기 중 일부를 공유함으로써 프리코스 과정에 참여하는 동안 이 친구들이 느꼈던 감정을 전해 본다.↵↵↵  ↵    프리코스는 project driven, 자기 주도적인 학습 방식으로 진행됩니다.↵    좋은 코드를 짜는 것, 너무나 중요합니다.↵    코스 정말 재미있고 배울 것들 너무 많습니다. 그리고 어디 가서 이렇게 코드리뷰 받아볼 수 있는 기회 별로 없습니다.↵  ↵↵  [우아한 테크코스] 프리코스 후기 글 중에서↵↵↵↵↵↵  누가 앞에서 공자왈 맹자왈 하지 않았는데도 스스로 느끼고 알아낸 점도 정말 정말 뿌듯한 일이다. 주도적으로 문제를 해결하려 하면, 알아야 하는 지식들이 어렵지 않고 오히려 재밌어지는 것을 다시 한번 확인했다.↵↵  그리고 무엇보다, 같은 코스를 진행하는 그 분과의 대화. 가장 즐거운 경험이었다. 내가 생각한 방법, 그가 생각한 방법, 그분이 나에게 해준 좋은 말… 지극히 즐겁고 감사한 일이다. 내가 세계 속에 있음을 느끼게 했다.↵↵  우아한테크코스 - 프리코스까지 글 중에서↵↵↵↵↵↵  여담인데, 실제로 최근의 저의 상태를 지켜보던 여자 친구가 했던 말입니다.↵↵  세상에 취업 준비를 이렇게 즐거워하면서 하는 사람이 어디 있어!↵↵  우아한 테크코스 - 프리코스 후기 글 중에서↵↵↵↵↵↵  가장 좋았던 점은 매주 과제에 대한 피드백이 이루어졌다는 것이다. 물론 많은 인원이 진행되는 과정이었기 때문에 개인별 피드백은 아니었지만, 참가자들의 과제를 리뷰하시면서 많은 사람들이 어려워하거나 알았으면 하는 점을 모아 전달해주는 점이 무엇보다 좋았다. 피드백을 통해 느끼는 점이 정말 많았으며 이로 인해 정말 많은 도움이 됐다.↵↵  2019년 우아한테크코스 프리코스까지의 후기 글 중에서↵↵↵↵↵최종 탈락 메일을 받은 후 다음과 같은 메일을 보내온 친구도 있다.↵↵↵  우아한 테크코스는 우물 안의 개구리였던 저에게 신세계의 존재를 가르쳐준 고마운 경험입니다. 그 자체로도 저는 이미 얻은 것이 많아서 행복합니다.↵↵  뭘 어떻게 공부해야 될지 추상적이었던 저에게 아직도 성장할 수 있는 부분이 많음을 깨우쳐주셔서 감사합니다.↵↵↵이 같은 참여후기와 메일을 받고 보니 과정을 설계하고, 평가하고, 피드백을 준 모든 과정이 보람으로 다가왔다. 프리코스에 적극적으로 참여한 모든 친구들에게 감사의 말을 전하고 싶다.↵↵프리코스 진행을 통해 느낀 점↵3주라는 짧은 기간 동안 프리코스를 진행하며 느낀 점을 정리하면서 글을 마친다.↵↵첫째, 지금까지 프로그래밍 연습을 하면서 코드 컨벤션을 지키라는 피드백을 받아본 경험이 있는 친구가 거의 없었다. 소프트웨어 교육을 진행할 때 최소한의 코드 품질 관련 교육이 진행되면 좋겠다.↵↵둘째, 동기부여가 높은 상태에서 ‘명확하고 구체적인 목표’를 달성하도록 과제를 제시한다면 과제를 진행하는 것이 고통이 아니라 즐거움이 될 수 있다. 과정을 잘 설계하면 학습이 재미있다는 경험을 전달할 수도 있겠다.↵↵셋째, 오프라인 과정을 최소화하고 온라인 과정을 통해서도 충분히 의미 있는 성장을 만들어 낼 수 있겠다. 지금까지 온라인과 오프라인을 병행해야만 의미 있는 과정을 만들 수 있겠다는 생각을 했는데 온라인 만으로도 충분히 의미 있는 결과를 만들 수 있는 과정을 설계할 수 있겠다.↵↵선발 과정을 통해 참 많은 것을 보고 배웠다. 하지만 본격적인 교육은 이제 시작이다. 본 교육 과정을 통해 또 다른 즐거움을 경험할 수 있기를 기대해 본다. 본 교육이 시작되는 5월 7일이 기대된다.',
          guid:
            'http://woowabros.github.io/woowabros/2019/05/02/techcourse.html',
          isoDate: '2019-05-01T23:00:00.000Z',
          link:
            'http://woowabros.github.io/woowabros/2019/05/02/techcourse.html',
          pubDate: 'Thu, 02 May 2019 08:00:00 +0900',
          title: '목적의식 있는 연습을 통한 효과적인 학습',
        },
      ],
      lastBuildDate: 'Fri, 10 May 2019 10:10:19 +0900',
      link: 'http://woowabros.github.io/',
      pubDate: 'Fri, 10 May 2019 10:10:19 +0900',
      title: '우아한형제들 기술 블로그',
    },
  },
};

function addFeed(state, feedUrl, feedData) {
  // eslint-disable-next-line no-shadow
  const { feed } = state;
  const feedName = feed[_.camelCase(feedData.title)] || undefined;

  if (feedName) {
    return state;
  }
  return {
    feed: {
      ...feed,
      [_.camelCase(feedData.title)]: {
        ...feedData,
        feedUrl: feedData.feedUrl || feedUrl,
      },
    },
  };
}

export default function feed(state = initialState, action) {
  switch (action.type) {
    case 'ADD_FEED':
      return addFeed(state, action.feedUrl, action.feed);
    default:
      return state;
  }
}
